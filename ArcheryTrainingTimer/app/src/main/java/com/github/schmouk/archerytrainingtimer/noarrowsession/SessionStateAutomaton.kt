package com.github.schmouk.archerytrainingtimer.noarrowsession

/**
 * Defines the signals that can be sent to the TimerStateAutomaton
 * to trigger state transitions.
 */
enum class ESignal {
    SIG_START,      // The Start button has been tapped
    SIG_STOP,       // The Stop button has been tapped
    SIG_REST_ON,    // The session is entering a rest period
    SIG_REST_OFF,   // The session is exiting a rest period
    SIG_COMPLETED,  // The session has completed
}

/**
 * Manages the state of the timer based on input signals.
 */
open class SessionStateAutomaton {

    /**
     * Defines the internal states of the automaton.
     * This is private as its direct manipulation should be controlled by the automaton.
     */
    protected enum class EState {
        STATE_IDLE,             // Timer is not active, ready to be configured or started
        STATE_TIMER_RUNNING,    // Main timer is actively counting down
        STATE_TIMER_STOPPED,    // Main timer was running but is now paused
        STATE_REST_MODE,        // Rest timer is actively counting down
        STATE_COMPLETED         // The entire session has completed
    }

    // Initialize the internal state to IDLE
    protected var currentState: EState = EState.STATE_IDLE
    var stateChanged: Boolean = false

    /**
     * Returns true if the internal state has changed since the last call to this method.
     * Calling this method resets the stateChanged flag to false.
     */
    fun hasStateChanged(): Boolean {
        val changed = stateChanged
        stateChanged = false
        return changed
    }


    /**
     * Processes an incoming signal generated by a user action and transitions the internal state accordingly.
     *
     * @param signal The ESignal to process, relates to the user or to the view actions.
     */
    open fun action(signal: ESignal) {
        when (currentState) {
            EState.STATE_IDLE, EState.STATE_COMPLETED -> {
                when (signal) {
                    ESignal.SIG_START -> {
                        // This is the only action that makes sense from IDLE state
                        // related with the finite state automaton associated with
                        // the training session timer:
                        // Start the main timer.
                        currentState = EState.STATE_TIMER_RUNNING
                        stateChanged = true
                    }
                    else -> {
                        // In IDLE or COMPLETED state, STOP, REST_ON, REST_OFF or
                        // COMPLETED signals can never happen. No state change occurs.
                    }
                }
            }
            EState.STATE_TIMER_RUNNING -> {
                when (signal) {
                    ESignal.SIG_STOP -> {
                        // User has paused the main timer
                        // Transition to TIMER_STOPPED state
                        currentState = EState.STATE_TIMER_STOPPED
                        stateChanged = true
                    }
                    ESignal.SIG_REST_ON -> {
                        // Typically, REST follows a completed timer run.
                        currentState = EState.STATE_REST_MODE
                        stateChanged = true
                    }
                    ESignal.SIG_COMPLETED -> {
                        // The training session has completed all of its countdowns.
                        currentState = EState.STATE_COMPLETED
                        stateChanged = true
                    }
                    else -> {
                        // START and REST_OFF signals in RUNNING state cannot happen.
                        // No state change occurs.
                    }
                }
            }
            EState.STATE_TIMER_STOPPED -> {
                when (signal) {
                    ESignal.SIG_START -> {
                        // This is the only action that makes sense from STOPPED state:
                        // Resume the main timer from where it was paused.
                        currentState = EState.STATE_TIMER_RUNNING
                        stateChanged = true
                    }
                    else -> {
                        // No other type of signal may happen in STOPPED state.
                        // No state change occurs.
                    }
                }
            }
            EState.STATE_REST_MODE -> {
                when (signal) {
                    ESignal.SIG_REST_OFF -> {
                        // This is the only type of signal that can be emitted
                        // by the application while in REST mode state.
                        // It indicates that the rest period has ended,
                        // and the main timer should resume.
                        currentState = EState.STATE_TIMER_RUNNING
                        stateChanged = true
                    }
                    ESignal.SIG_COMPLETED -> {
                        // The training session has completed all of its countdowns.
                        currentState = EState.STATE_COMPLETED
                        stateChanged = true
                    }
                    else -> {
                        // No other type of signal may happen in REST mode state.
                        // No state change occurs.
                    }
                }
            }
        }
    }

    // --- Public methods to query the current state ---

    fun isIdleMode(): Boolean = currentState == EState.STATE_IDLE

    fun isTimerRunning(): Boolean = currentState == EState.STATE_TIMER_RUNNING

    fun isTimerStopped(): Boolean = currentState == EState.STATE_TIMER_STOPPED

    fun isTimerActivated(): Boolean = isTimerRunning() || isTimerStopped()

    fun isRestMode(): Boolean = currentState == EState.STATE_REST_MODE

    fun isSessionCompleted(): Boolean = currentState == EState.STATE_COMPLETED

    /**
     * Resets the automaton to its initial idle state.
     * Useful for when the entire timer sequence is reset.
     */
    fun reset() {
        currentState = EState.STATE_IDLE
        stateChanged = true
    }

    /**
     * Provides a string representation of the current internal state.
     * Useful for debugging.
     */
    override fun toString(): String {
        return "noarrowsession.TimerStateAutomaton(currentState=$currentState)"
    }
}
