package com.github.schmouk.archerytrainingtimer.noarrowsession

/**
 * Defines the signals that can be sent to the TimerStateAutomaton
 * to trigger state transitions.
 */
enum class ESignal {
    SIG_START,      // The Start button has been tapped
    SIG_STOP,       // The Stop button has been tapped
    SIG_REST_ON,    // The session is entering a rest period
    SIG_REST_OFF,   // The session is exiting a rest period
    SIG_COMPLETED,  // The session has completed
}

/**
 * Manages the state of the timer based on input signals.
 */
class TimerStateAutomaton {

    /**
     * Defines the internal states of the automaton.
     * This is private as its direct manipulation should be controlled by the automaton.
     */
    private enum class EState {
        STATE_IDLE,          // Timer is not active, ready to be configured or started
        STATE_TIMER_RUNNING, // Main timer is actively counting down
        STATE_TIMER_STOPPED, // Main timer was running but is now paused
        STATE_REST_MODE      // Rest timer is actively counting down
    }

    // Initialize the internal state to IDLE
    private var currentState: EState = EState.STATE_IDLE

    /**
     * Processes an incoming signal generated by a user action and transitions the internal state accordingly.
     *
     * @param signal The ESignal to process.
     */
    fun userAction(signal: ESignal) {
        when (currentState) {
            EState.STATE_IDLE -> {
                when (signal) {
                    ESignal.SIG_START -> {
                        // This is the only action that makes sense from IDLE state
                        // related with the finite state automaton associated with
                        // the training session timer:
                        // Start the main timer.
                        currentState = EState.STATE_TIMER_RUNNING
                    }
                    else -> {
                        // In IDLE state, STOP, REST_ON, REST_OFF or COMPLETED
                        // signals can never happen. No state change occurs.
                    }
                }
            }
            EState.STATE_TIMER_RUNNING -> {
                when (signal) {
                    ESignal.SIG_STOP -> {
                        // User has paused the main timer
                        // Transition to TIMER_STOPPED state
                        currentState = EState.STATE_TIMER_STOPPED
                    }
                    ESignal.SIG_REST_ON -> {
                        // Typically, REST follows a completed timer run.
                        currentState = EState.STATE_REST_MODE
                    }
                    ESignal.SIG_COMPLETED -> {
                        // The training session has completed all of its countdowns.
                        // So, it gets back to its initial IDLE state.
                        currentState = EState.STATE_IDLE
                    }
                    else -> {
                        // START signal in RUNNING state cannot happen.
                        // No state change occurs.
                    }
                }
            }
            EState.STATE_TIMER_STOPPED -> {
                when (signal) {
                    ESignal.SIG_START -> {
                        // This is the only action that makes sense from STOPPED state:
                        // Resume the main timer from where it was paused.
                        currentState = EState.STATE_TIMER_RUNNING
                    }
                    else -> {
                        // No other type of signal may happen in STOPPED state.
                        // No state change occurs.
                    }
                }
            }
            EState.STATE_REST_MODE -> {
                when (signal) {
                    ESignal.SIG_REST_OFF -> {
                        // This is the only type of signal that can be emitted
                        // by the application while in REST mode state.
                        // It indicates that the rest period has ended,
                        // and the main timer should resume.
                        currentState = EState.STATE_TIMER_RUNNING
                    }
                    else -> {
                        // No other type of signal may happen in REST mode state.
                        // No state change occurs.
                    }
                }
            }
        }
    }

    // --- Public methods to query the current state ---

    fun isIdleMode(): Boolean = currentState == EState.STATE_IDLE

    fun isTimerRunning(): Boolean = currentState == EState.STATE_TIMER_RUNNING

    fun isTimerStopped(): Boolean = currentState == EState.STATE_TIMER_STOPPED

    fun isRestMode(): Boolean = currentState == EState.STATE_REST_MODE

    /**
     * Resets the automaton to its initial idle state.
     * Useful for when the entire timer sequence is reset.
     */
    fun reset() {
        currentState = EState.STATE_IDLE
    }

    /**
     * Provides a string representation of the current internal state.
     * Useful for debugging.
     */
    override fun toString(): String {
        return "noarrowsession.TimerStateAutomaton(currentState=$currentState)"
    }
}
